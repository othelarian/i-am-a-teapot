# EarlGrey documentation

## What's the EarlGrey class?

The `EarlGrey` class as the responsability to generate the html output, at compilation time to generate the `index.html` but also on the webapp itself when the user click to download or synchronize the app. It can also be used to generate part of the app, like by using a plugin.

## How it works?

The `EarlGrey` class has to be instanciate first, and then you can inflate the generated object with new elements by using its methods. An `EarlGrey` object represent an html tag, like `a` or `div`. Internally the class keep track of children object in an array, building a tree like in plain html. A child can be an `EarlGrey` object too (a child tag) or a String.

Here is an example of creating an `EarlGrey` object and adding 2 children, one String and one `div` tag with a `class` attribute.

```LiveScript
tea = new EarlGrey!
tea.push 'This is a text'
tea.push(EarlGrey.tag 'div', {class: 'a-class'})

console.log tea.to-string!
```

The `console.log` instruction will return this:

```html
<!DOCTYPE html><html>This is a text<div class="a-class"/></html>
```

It's possible to set up the `EarlGrey` class with some aliases to avoid the `EarlGrey.tag` call, replacing it by the name of the tag. Also, it's possible to add multiple children with one call using the `obj.bag` method. Here is the new code (note that we use `EarlGrey.compile` to do the setup):

```LiveScript
EarlGrey.compile ['div']
tea = new EarlGrey!bag do
  'This is a text'
  EarlGrey.div {class: 'a-class'}

console.log tea.to-string!
```

## API reference

Note: this API uses the LiveScript notation in kebab-case, but compile in CamelCase on the JavaScript side.

### Other exports

Coming with the `EarlGrey` class, there's 2 exported arrays, containing tags ready to be injected to the `EarlGrey.compile` method.

* `earl-html` => most used html tags
* `earl-svg` => most used svg tags

### Static methods

* `EarlGrey.compile(array)` => the array must be a list of tags. It creates aliases to use the tag's names as method instead of using the `EarlGrey.tag` method directly. Return nothing.
* `EarlGrey.from-json(json) -> new EarlGrey` => taking a json and create an `EarlGrey` object, children included. The format must be the same as the one generated by calling the `tea.to-json` method (see below). Return a new `EarlGrey` object.
* `EarlGrey.tag(name, ...opts) -> neww EarlGrey` => the main method of the `EarlGrey` class, it takes a tag's name (with no limitation), some options, and return a new `EarlGrey` object. The options can be (with this order):
  * a object with all the tag's attributes
  * an array of compatible `EarlGrey` children (ie. String or `EarlGrey` object)
  * as many children as you want, each as an argument (works like the `tea.bag` method, see below)

### Constructor

Here is the detailed constructor, with all its arguments and their default values:

```LiveScript
new EarlGrey dt = '', name = '', attrs = {}, children = []
```

Arguments explanations:

* `dt` => the doctype, if let blank then the `EarlGrey` class will define it as `html`. The `EarlGrey.tag` static method set the doctype to `tag`, and this can also be done to avoid any automatic rewrite.
  Note: html is currently the only doctype automatically defined, but it's possible to rewrite it by using the `tea.doctype` method (see below).
* `name` => the name of the tag. If the `name` and `dt` arguments are blank, or the `name` is blank and the `dt` is defined as `html`, then the tag's name is automatically defined as `html`.
* `attrs` => the tag's attributes, as a JSON object.
* `children` => an array of `EarlGrey` compatible children (ie. Strings or `EarlGrey` objects).

### Object's methods

All the methods belows are only available for an `EarlGrey` object (called `tea` here).

* `tea.clean -> tea` => remove all the object's children. Returns the object itself.
* `tea.delete(index) -> tea` => remove the object's child at the given `index`. If the `index` is bigger than the children's array length then this method throw an error. Returns the object itself.
* `tea.doctype(doctype) -> tea` => set up a new doctype. Returns the object itself.
* `tea.bag(...children) -> tea` => takes children as arguments (one for one) and add them to the children's array. Use `tea.push` internally. Throws an error if a child isn't a String or an `EarlGrey` object. Returns the object itself.
* `tea.insert(index, child) -> tea` => Take a compatible child (String or `EarlGrey` object) and insert it at the given `index`. Throws an error if the child isn't compatible (technically the `index` can be anything, there's no error triggered, the `splice` method used internally accepts everything). Returns the object itself.
* `tea.push(child) -> tea` => add a child at the end of the children's array. Throws an error is the child isn't compatible. Returns the object itself.
* `tea.to-json -> json` => returns the `EarlGrey` object as a json object, converting all its children in the same format too recursively.
* `tea.to-string -> string` => returns the `EarlGrey` object as a string, converting the object and all its compatible children into a tag with attributes and children tags, like html, xml and svg.
